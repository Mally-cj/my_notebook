## 第二章 信号的表示和处理

### 2.1 信息的存储

2020.5.30

1. 

* 8位的块，构成字节，时最小的可寻址的内存单位，但不是访问内存种的单独的位。
* 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存

2. 字节

   每台计算机都又一个==字长==，它觉得虚拟地址位置空间的最大大小，如对于一个字长为w位的机器而言，虚拟地址的范围为$0$~$2^w -1$,

   程序最多访问$2^{w}$个字节

3. “32位程序”和“64位程序”区别在于该程序是如何编译的，而不是其运行的机器类型。

   ```bash
   linux> gcc -m32 prog.c   \\能在32位和64位机器上运行
   linux> gcc -m64	prog.c	 \\只能在64位机器运行
   ```

> 为避免不同编译器和机器不同带来的错误，ISO C99引入一类数据类型，数据大小是固定的，不随编译器和机器设置而改变。

4. 机器存储对象的字节的顺序规则$\begin{cases}
   小端法把最高有效字节排到最前面，如 39\,30\,00 \,00\\
   大端法:把最高有效字节排到最前面（常用）如00\,00\,30\,39\\
   \end{cases}$

    新的处理器大小端都可以用，但是一旦选择了特定的操作系统，字节顺序也就固定了

5. 掩码的新理解

   某一位上的掩码为1，表示相应位的信号i是有效的（使能），反之信号被屏蔽。

6. 移位运算

   * 逻辑位移：在左端补k个0

   * 算术位移：在左端补k个最高有效位的值。（通常都使用这个）

     |                |                               |      |
     | -------------- | ----------------------------- | ---- |
     | x              | [0110011] [10010101]          |      |
     | x>>4(逻辑位移) | [**0000**0110] [**0000**1001] |      |
     | x>>4(算术位移) | [**0000**0110] [**1111**1001] |      |

   

### 2.2整数表示

1.用关键字（char，short，long）可以指定大小，用unsighed指示无符号（或者加后缀字符U，如123U），默认为有符号

| C数据类型(64位程序) | 最小值 | 最大值 |
| ------------------- | ------ | ------ |
| char                | -128   | 127    |
| unsigned char       | 0      | 255    |
| short               | -32768 | 32768  |
| unsigned short      | 0      | 65535  |

2.

原码（无符号数编码的定义）：
$$
B2U_w(x)=\sum_{i=0}^{w-1}x_i2^i
$$
补码：最高有效位为负权
$$
B2T_w(x)=-x_w2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
$$

* 补码的范围不对称|TMin|=|TMax|+1

  

3.强制类型转换

强制类型转换的结果位值保持不变，只是改变了解释这些位的方式。

因此当一个有符号数映射位它相应的无符号数时，负数的值会加上$2^w$,正数保持不变。

4.

扩展一个w位的数字的位（增加k位）表示：在左端添加k位最高有效位。

减少一个w位的数字的位（减少k位（表示：丢弃高w-k位。



