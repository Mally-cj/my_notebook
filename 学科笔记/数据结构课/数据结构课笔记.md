# 数据结构课笔记

### lesson1

#### 函数指针

```c++
* 给定9阶多项式 f(x)=1*x+2*(x^2)+...+9*(x^9) */
/* 用不同方法计算f(1.1)并且比较运行时间                         */

#include <stdio.h>
#include <time.h>
#include <math.h>

clock_t start, stop;
double duration;
#define MAXN 10  /* 多项式最大项数，即多项式阶数+1 */
#define MAXK 1e7 /* 被测函数最大重复调用次数*/

double f1( int n, double a[], double x )
{
	int i;
	double p = a[0];
	for ( i=1; i<=n; i++ )
		p += (a[i] * pow(x, i));
	return p;
}

double f2( int n, double a[], double x )
{
	int i;
	double p = a[n];
	for ( i=n; i>0; i-- )
		p = a[i-1] + x*p;
	return p;
}

void run( double (*f)( int, double*, double ), double a[], int case_n )
{
	/* 此函数用于测试被测函数(*f)的运行时间，并且根据case_n输出相应的结果 */
	/* case_n是输出的函数编号：1代表函数f1；2代表函数f2                   */
	int i;

	start = clock();
	for ( i=0; i<MAXK; i++ ) /* 重复调用函数以获得充分多的时钟打点数*/
		(*f)(MAXN-1, a, 1.1);
	stop = clock();

	duration = ((double)(stop - start))/CLK_TCK;
	printf("ticks%d = %f\n", case_n, (double)(stop - start));
	printf("duration%d = %6.2e\n", case_n, duration);
}

int main ()
{
	int i;
	double a[MAXN]; /* 存储多项式的系数*/

	/* 为本题的多项式系数赋值，即a[i]=i */
	for ( i=0; i<MAXN; i++ ) a[i] = (double)i;

	run(f1, a, 1);
	run(f2, a, 2);

	return 0;
}

```

## lesson2

数组名做函数参数

递归要有一个终止条件

看到18：23

通过 用解释阶乘的方式解释 递归

用汉诺塔 解释递归模型：

只有3个盘子的时候，终止条件其实是

1，只对1号盘子处理，无特殊盘子

```
void move(int n,char a,char b,char c)
{//a是源，b是中间过渡
if(n>=1)
{
move(n-1,a,c,b);  //移动了n个
printf("%d from"); //剩余1个，且位n号盘子，
move（n-1）,b,a,c);  //移动n-1个
}
}
```



二叉树描述递归调用的过程，根据过程判断f的输出

二叉树是对称的



感受：

从我的角度（已经很熟悉递归的角度）：

1.用阶乘去解释递归的例子很常见，以前不明白为什么循环能做的事要用递归解释，这堂课发现确实是个讲递归入门的简单例子

2.一步步升难，到汉诺塔，体现了递归解决问题的原始思想。

3.升华递归到二叉树，这是为后面做铺垫。意外发现还有对称特性

上一节课讲循环讲到了 最大子序列，这节课引到了树，进程非常地快，如果不是我已经知道了大体的东西，会感觉每一节都是极度烧脑，发现新世界。

so 建议1：要不要课前先抛几个问题，让同学们去思考如何解决？到了课上，再去讲解决这个问题的算法，比如青蛙的问题，可以提前让同学们思考的。

如果仔细听，会发现这2节课过渡流畅，但是这样快的进度，也很好奇这会是一个怎么样的庞大系统。

so建议2：要不要先介绍一下接下来的课的系统，知道接下来要学哪些，他们是怎么连起来的。



## lesson3 2020.4.15

* 最长递增子序列

* 递增子序列最大值

## lesson4 2020.4.21

首尾最长串

首尾最长串只有1个，如何描述它，给定一个值来



记有s[0...k]为前缀，s[i-k...i]为后缀

next[i]表示使子串 s[0...i]的前缀s[0...k]等于后缀s[i-k...i]的最大的k

课程内容：

几乎都在讲next数组

原来对kmp的next数组还是不够深刻理解，反复听了这节课再加上 胡凡的《算法笔记》里的，终于把next数组搞明白了。



## lessonn5 2020.4.23

:one:课程内容：

1.**结构体和union的区别**

结构体：把多个元素放在一起形成一个整体

union：多个元素共用存储空间

2​.:star:**链表**  定义，使用typedef更美观 

3.链表操作：翻转

4.取中位数 其实是选择排序

:two:收获：

1.知道联合体

2.get漂亮的链表写法





## Lesson6 2020.4.28

一.课程内容

1.讲了线性表的顺序存储和链式存储

2.顺序存储 就和数组一样，先固定了大小，但是这里不同的是，把它变成了一个结构体

```
typedef int Position;
typedef struct LNode* PtrToLNode;

struct LNode
{
	ElementType Data[MAXSIZE];
	Position Last;
};
typedef PtrToLNode List;

```

链式存储就是拼接，不用了释放

```
typedef struct LNode * PtrToLNode;
typedef int Elementdate;
struct LNode{
    Elementdate Date;
    PtrToLNode Next;
};
typedef PtrToLNode List;   //链表的头节点
```

从结构体看，两个不同的地方就在于 顺序存储的一个结构体单元就是一个表了，而链式存储的一个结构体单元只是表的其中一个元素。

3.关于链式存储的头节点，

头节点里不存数据，会方便进行一些其他操作，比如删除。



不理解的地方是，显然链性表有大小可变换的优势，那么什么时候要用顺序表呢





***

具体的课堂笔记，杂杂的

3.0.1

1.线性结构的含义：从前向后的单一结构形式

2实现方式：用链表实现

3.基本函数   ：插入元素，删除

4.具体实现代码与结构的实现方式

5.应用：比如图书馆查询系统



3.0.2第一种具体结构（具体实现）

```
typedef int Position;
typedef struct LNode* PtrToLNode;

struct LNode
{
	ElementType Data[MAXSIZE];
	Position Last;
};
typedef PtrToLNode List;

```

3.1

```
List MakeEmpty()
{
	List L;
	L = (List)malloc(sizeof(struct LNode));
	L->Last = -1;
	return L;
}
```

3.2

有2种预定义的方式

```
#define ERROR -1
Position Find(List L, ElementType X)
{
	Position i = 0;
	while (i <= L->Last && L->Data[i] != X)i++;
	if (i > L->Last)return ERROR;
	else return i;
}
```

3.3

```
bool Insert(List L, ElementType X, int i)
{
	Position j;
	if (L->Last == MAXSIZE - 1) {
		printf("表满");
		return false;
	}
	if (i<1 || i>L->Data + 2) {
		printf("位序不合法");
		reurn false;
	}
	for (j = L->Last; j = i - 1; j--)
		L->Data[j + 1] = L->Data[j];
	L->Data[i - 1] = X;
	L->Last++;
	return true;

}
```

具体实现与结构的实现方式有关系



第一种具体结构

2种预定义的方式，define并不推荐使用



```
#include <iostream>
const int MAXSIZE = 100;
typedef int ElementType;

typedef int Position;
typedef struct LNode* PtrToLNode;

struct LNode
{
	ElementType Data[MAXSIZE];
	Position Last;
};
typedef PtrToLNode List;


List MakeEmpty()
{
	List L;
	L = (List)malloc(sizeof(struct LNode));
	L->Last = -1;
	return L;
	
}

#define ERROR -1
Position Find(List L, ElementType X)
{
	Position i = 0;
	while (i <= L->Last && L->Data[i] != X)i++;
	if (i > L->Last)return ERROR;
	else return i;
}
int main(void)
{
	int t = 0;
	PtrToNode p = (PtrToNode)malloc(sizeof(struct Node));
	PtrToNode Temp, List;
	List = p;
	for (int i = 0; i < 10; i++)
	{
		Temp = p;
		PtrToNode p = (PtrToNode)malloc(sizeof(struct Node));
		Temp->Next = p;
		Temp->Date = i;
	}
	Temp = List;
	for (int i = 0; i < 10; i++)
	{
		t += Temp->Date;
		Temp = Temp->Next;

	}
	printf("%d", t);
	return 0;

}

```



malloc返回 void*指针，即指针不定，故而要加强制转换

3.9带头结点的链表

普通链表的第一个节点

带头节点的链表，

why要带头节点，因为要删除的时候不会把整个表删除了。



带头节点和不带头节点



***



## Lesson7 2020.4.30

**一.课程内容**

**1.栈**

栈：后进先出的线性表

栈和队列中描述位置的变量要注意其含义 ，建栈时top=-1，因为top一直是最后一个元素的下标。

```
typedef int Position;
struct SNode{  //这里用顺序表实现
ElementType *Data;  //存储元素的数组
Position Top;		//栈顶指针
int MaxSize;  		//堆栈的最大容量
}
typedef struct SNode *stack;
```



**2.计算表达式(上节课的)**

目的：希望去掉括号，去掉优先级计算

解决办法：转换为后缀表达式

特点：无括号，无有限

过程：遇到运算符号，就取最近的2个数计算，并得到结果

**3.生成后缀表达式**

后缀表达式如何生成？（即从中缀表达式如何变成后缀表达式）

1.如果是数，直接输出

2如果是运算符，

如果它比栈顶的运算符优先级别高，就直接入栈。

反之，就一直弹出栈内的元素，直到有个栈顶元素比它高或者栈为空，再入栈。

（其中左括号的优先级最高，右括号的优先级最低）

**二.收获**

使用枚举类型使得代码更加简明

```
typedef enum{num,opr,end}Type
```

使用时

```
Type GetOp（char *Expr，int *start，char *str）
{
...
if(i==0)return end;
else if(isdigit(str[0])||isdigit(str[1]))return num;
else return opr;
}
```

