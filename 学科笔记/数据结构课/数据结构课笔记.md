# 数据结构课笔记

### lesson1

#### 函数指针

```c++
* 给定9阶多项式 f(x)=1*x+2*(x^2)+...+9*(x^9) */
/* 用不同方法计算f(1.1)并且比较运行时间                         */

#include <stdio.h>
#include <time.h>
#include <math.h>

clock_t start, stop;
double duration;
#define MAXN 10  /* 多项式最大项数，即多项式阶数+1 */
#define MAXK 1e7 /* 被测函数最大重复调用次数*/

double f1( int n, double a[], double x )
{
	int i;
	double p = a[0];
	for ( i=1; i<=n; i++ )
		p += (a[i] * pow(x, i));
	return p;
}

double f2( int n, double a[], double x )
{
	int i;
	double p = a[n];
	for ( i=n; i>0; i-- )
		p = a[i-1] + x*p;
	return p;
}

void run( double (*f)( int, double*, double ), double a[], int case_n )
{
	/* 此函数用于测试被测函数(*f)的运行时间，并且根据case_n输出相应的结果 */
	/* case_n是输出的函数编号：1代表函数f1；2代表函数f2                   */
	int i;

	start = clock();
	for ( i=0; i<MAXK; i++ ) /* 重复调用函数以获得充分多的时钟打点数*/
		(*f)(MAXN-1, a, 1.1);
	stop = clock();

	duration = ((double)(stop - start))/CLK_TCK;
	printf("ticks%d = %f\n", case_n, (double)(stop - start));
	printf("duration%d = %6.2e\n", case_n, duration);
}

int main ()
{
	int i;
	double a[MAXN]; /* 存储多项式的系数*/

	/* 为本题的多项式系数赋值，即a[i]=i */
	for ( i=0; i<MAXN; i++ ) a[i] = (double)i;

	run(f1, a, 1);
	run(f2, a, 2);

	return 0;
}

```

###

## lesson2

数组名做函数参数

递归要有一个终止条件

看到18：23

通过 用解释阶乘的方式解释 递归

用汉诺塔 解释递归模型：

只有3个盘子的时候，终止条件其实是

1，只对1号盘子处理，无特殊盘子

```
void move(int n,char a,char b,char c)
{//a是源，b是中间过渡
if(n>=1)
{
move(n-1,a,c,b);  //移动了n个
printf("%d from"); //剩余1个，且位n号盘子，
move（n-1）,b,a,c);  //移动n-1个
}
}
```



二叉树描述递归调用的过程，根据过程判断f的输出

二叉树是对称的



感受：

从我的角度（已经很熟悉递归的角度）：

1.用阶乘去解释递归的例子很常见，以前不明白为什么循环能做的事要用递归解释，这堂课发现确实是个讲递归入门的简单例子

2.一步步升难，到汉诺塔，体现了递归解决问题的原始思想。

3.升华递归到二叉树，这是为后面做铺垫。意外发现还有对称特性

上一节课讲循环讲到了 最大子序列，这节课引到了树，进程非常地快，如果不是我已经知道了大体的东西，会感觉每一节都是极度烧脑，发现新世界。

so 建议1：要不要课前先抛几个问题，让同学们去思考如何解决？到了课上，再去讲解决这个问题的算法，比如青蛙的问题，可以提前让同学们思考的。

如果仔细听，会发现这2节课过渡流畅，但是这样快的进度，也很好奇这会是一个怎么样的庞大系统。

so建议2：要不要先介绍一下接下来的课的系统，知道接下来要学哪些，他们是怎么连起来的。



## lesson3 2020.4.15

* 最长递增子序列

* 递增子序列最大值

### lesson4 2020.4.22

首尾最长串

首尾最长串只有1个，如何描述它，给定一个值来



记有s[0...k]为前缀，s[i-k...i]为后缀

next[i]表示使子串 s[0...i]的前缀s[0...k]等于后缀s[i-k...i]的最大的k