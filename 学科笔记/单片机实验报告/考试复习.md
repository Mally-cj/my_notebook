单片机课的主要内容
* 单片机的内部组成及工作原理
* 单片机C语言程序设计
* 单片机系统中常见内部、外部接口电路

### 第一章 绪论

1. 单片机封装类型

   双列直插式封装（DIP）；薄型四方扁平式封装（ LQFP ）；小外形封装（SOP）；方形扁平无引脚（QFN）

2. 单片机的位数代表的含义？

   计算机内部以及CPU与外部设备间通信时，一次同时处理的二进制数据的位数，位数越多，表示计算机处理数据的能力越强。

3. 嵌入式系统框架

4. 单片机硬件框图

5. 单片机编程语言

   从低级到高级:	$微指令\rightarrow 机器语言\rightarrow汇编语言\rightarrow高级语言$

6.单片机系统开发流程主要包括硬件设计流程和软件设计流程
![mark](http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200702/085948303.png)

   7.命名规则，课本P15

###  第二章 keil的使用

### 第三章 单片机CPU子系统

#### Part 1 CPU内核功能单元

![mark](http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200702/092220310.png)

1. 程序计数器（Program Counter，PC）

    * 通过PC从程序存储器中不断地取出所要执行的代码。PC的特点就是总是指向下一条所要执		行的指令的地址。
    * PC其实质就是实现递增功能的计数器，其计数值是程序存储器的地址。
    * PC的宽度为16位。因此，地址深度为216，即64K，地址的范围为0~65535。
    * 程序计数器并不总是递增的，因为执行机器指令可以分成顺序执行和非顺序执行。

2. 双数据指针（Dual Data Pointer，DPTR）

    * 用于对16位地址的程序存储器和扩展RAM进行访问。
    * 数据指针，存放16位地址，由DPL（低8位）和DPH（高8位）组成。
    * DPTR是8051中唯一可以直接进行16位操作的寄存器；此外，也可以按照字节分别对DPH		和DPL进行操作。

3. 堆栈及指针（Stack Pointer，SP）

    * 用于控制指向堆栈空间位置的是堆栈指针SP

    * 它是一个8位的专用寄存器

4. 在程序状态字（Program Status Word，PSW），保存一些具有特殊含义的比特位，这些位反映当前8051 CPU内的工作状态。

#### Part2 存储器

IAP15W4K58S4单片机内部在物理上主要有3个相互独立的存储器空间：
程序存储器（程序Flash）、片内基本RAM、片内扩展RAM。

1. **程序存储器**：

     * 存放用户程序，使单片机按用户程序指定的流程与规则允许，存放一些常数或表格数据。
     * 常数可以作为程序通过ISP下载程序到程序存储器，但是程序运行过程中，程序存储器的内容只能读取，不能写入。
     
     * 单片机设置一个16位的程序计数器（PC），用于指示下一时刻CPU将要所执行的程序在ROM空间中的地址；
       PC指针长度为16位，所以单片机的程序存储器空间最大为64kB；
2. 片内基本RAM分为低字节RAM,高字节RAM,特殊功能寄存器SFR

   * 片内基本RAM就是 stc的数据存储器，存储单片机运行期间所需要的数据和临时生成的数据，需要能够快速读出和写入数据。此类存储器掉电后，存储的数据会丢失，不能永久保存。

   * **低字节RAM**（00-~7F)包含 工作寄存器组区，可位寻址区，用户RAM区域和堆栈区

   * 高字节RAM与SFR共用地址（80~FF), 通过不同的寻址方式来区分。高字节RAM只能用寄存器间接寻址进行访问，SFR只能用直接寻址进行访问。
    定义变量时，若要存储在高128字节RAM区域，变量的存储类型定义为“idata”，而SFR直接用寄存器名字进行存取操作就可。
	
3. **片内扩展RAM** 也就时外部数据存储器
     * 单片机片内RAM存储器不够使用时，单片机可以通过外部总线扩展的片外数据存储器获得更大的存储空间。
     * 由于外部地址总线宽度为16位，所以片外RAM扩展最多64KB，地址范围为0000H-0FFFFH。

### 第四章 C语言

#### 1.  单片机扩充的数据类型

* bit类型
  该数据类型可用于定义一个比特位
  但是不能定义位指针，也不能定义位数组。

* sfr类型

    * 该数据类型可以用于定义8051单片机中的所有内部8位特殊功能寄存器SFR。

    * sfr类型数据占用存储空间一个字节，取值范围为0~255。定义的格式：

      ```
      sfr 标识符 =地址;
      ```
    * 可以直接使用在<reg51.h>中已经定义的sfr类型。

* sbit类型
  该数据类型可以用于定义8051单片机内的RAM中可寻址位或者特殊功能寄存器中的可寻址位。定义的格式为：

  ```
  sbit CY   = 0xD7;
  ```

  

#### 2. Ifndef

Ifndef 是 if not defined的简写，是宏定义的一种，是预编译指令中的一种条件编译
#ifndef x //先测试x是否被宏定义过
#define x
程序段1 //如果x没有被宏定义过，定义x，并编译程序段 1
#else
程序段2 //如果x已经定义过了则编译程序段2的语句，“忽视”程序段 1
#endif//终止ifP

#### 3.变量存储模式定义功能

 [存储种类]   数据类型   [存储器类型]   变量名列表;

* 存储种类和存储器类型是可选项。
* 变量的存储种类有四种，包括：auto（自动）、extern（外部）、static（静态）和register（寄存器）。在没有明确说明变量的存储种类时，默认auto。
* <img src="http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200702/104242824.png" alt="mark" style="zoom:50%;" />

#### 4.预编译指令

在编写C语言程序时，可以将预处理命令添加到需要的位置，但它只在编译程序时起作用，且通常是按行进行处理，因此又称为编译控制行。

* 宏定义 #define 标识符 常量表达式

* 条件编译：一般情况下，希望对所有的程序行进行编译。但是有时希望只对其中的一部分内容在满足一定的条件时才进行编译，这就是条件编译。Keil Cx51编译器的预处理器提供了三种条件编译格式：

  <img src="http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200702/111538104.png" alt="mark" style="zoom: 50%;" />

  

#### 5.复杂数据结构

* **联合**不像结构类型那样，所有的数据单独分配存储空间，而联合数据类型是共用存储空间。

  ```c
  union {                                    	//定义联合体
         	char data_str[8];               //定义字符数组
         	struct {                               //定义结构体
                  		  int  a;
                  	  int  b;
                  	  long int c; 				 		             
                   }data_var;
  	}shared_information;         //联合体的名字
  
  ```

  

#### 6.C程序中使用汇编语言

* 在C语言中使用汇编语言的方法包括两种：
  在C语言程序代码中内嵌汇编语言；
  C语言代码程序，调用外部汇编语言编写的程序。

* 在C源文件中，将汇编代码写在指令：#pragma asm….. #pragma endasm中间。

  ```AS
  #pragma asm                //内嵌汇编命令，表示开始
     	 MOV A,0x22           //单片机片内数据区0x22单元内容送给累加器ACC
     	 MOV B,0x24           //单片机片内数据区0x24单元内容送给寄存器B
     	 ADD A,B                  //累加器ACC和寄存器B的内容相加，结果保存ACC
     	 MOV 0x26,A           //累加器ACC内容送到单片机片内数据区0x26单元。
   	#pragma endasm        //内嵌汇编命令，表示结束
   	e=D1;                           //将D1的值送给e
  	printf(“%d\n”,e);     //打印e的值
  	while(1);
  
  ```
第6章

### STC单片机时钟

1. 时钟源的选择

   * 外部时钟：

     由XTAL1、XTAL2引脚外接石英晶体和微调电容产生时钟信号，时钟信号的频率取决于晶振的频率，电容器的作用是稳定频率和快速起振。
   * 内部RC振荡器时钟
   
     （一般外部的晶振比较精确，而内部的成本低）

2. 可编程时钟分频器

   时钟源信号记为$f_{osc}$,	系统时钟记为$f_{SYS}$ ,N为分频系数
   $$
   f_{SYS}=f_{OSC}/N
   $$
   ![mark](http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200608/121449333.png)

### STC单片机复位



![mark](http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200608/121754898.png)

STC15系列单片机提供了7种复位方式，包括：
外部RST引脚复位
软件复位
掉电复位/上电复位
看门狗复位
内部低压检测复位
MAX810专用复位电路复位
程序地址非法复位。



### STC单片机电源模式

STC15系列单片机提供了三种运行模式，以降低系统功耗，即：
低速模式、空闲模式和掉电模式。
典型地，对于STC15系列单片机来说：
正常工作模式下，功耗为2.7mA~7mA；
空闲模式下，功耗为1.8mA；
掉电模式下，功耗为0.1μA。

1. 低速模式

   低速模式由时钟分频器CLK_DIV控制。
   通过对主时钟分频从而降低单片机工作时钟频率，降低功耗以及EMI

2. 空闲模式

   * 将IDL/PCON.0位置1，单片机将进入IDLE（空闲）模式。

   * 在空闲模式下，仅CPU无时钟，但是外部中断、内部低压检测电路、定时器、ADC转换器等仍正常工作。

   * 数据RAM、堆栈指针SP、程序计数器PC、程序状态字PSW、累加器A等寄存器都保持原有的数据。而外设的IO口电平保持不变

     

3. 掉电模式
   * 内部掉电唤醒定时器是一个15位的定时器，由特殊功能寄存器地址为0xAA的WKTCL寄存器，以及地址为0xAB的WKTCH寄存器进行管理和控制。
   * 内部掉电唤醒专用定时器计数时间由下面公式确定：
                    [106μS/掉电唤醒专用定时器时钟频率]×16×计数次数
     例如：如果定时器时钟频率为32768Hz，则内部掉电唤醒专用定时器最短计数（计数一次）的时间为：
                    [106μS/32768] ×16×1=488.28 μS

### 第7章 定时器

1. 定时器/计数器的工作原理

   定时器/计数器核心部件就是一个做加法运算的计数器，其本质就是对脉冲进行计数。根据信号源的不同分别叫做定时器和计数器。

   <img src="http://mally.oss-cn-qingdao.aliyuncs.com/PicGo上传的图片/20200608/183749734.png" alt="mark" style="zoom:50%;" />

2. 计算公式

   * 定时时间t=（计数器的最大空间-计数初值）*计数周期= $(2^n-a)\times 12f_{sys}(\mu s)$ 或$(2^n-a)\times f_{sys}(\mu s)$

   * 计数器的次数N=计数器的最大空间-计数初值=$2^n-a$

     （由于检测一个下降沿需要2个机器周期，即24个振动周期$\rightarrow$ 最高计数频率 $\frac{1}{24}f_{sys}$ ,$f_{sys}=12MHz$ 时，外部脉冲的最大允许频率为0.5MHz）

3. 定时器/计数器工作模式

   定时器/计数器0有4种工作模式：

   * 模式0（16位自动重新加载模式）；
     模式1（16位不可重加载模式）；
     模式2（8位自动重加载模式）；
     模式3（不可屏蔽中断的16位自动重加载模式）。

   * 定时器/计数器1工作模式有模式0、1、2。
   * 时器/计数器2、3、4的工作模式固定为模式0

### 第8章 串行通信

并行通信

* 将数据的各位用多条数据线同时进行传输。
   优点：传输速度相对较快；缺点：占用引脚多、成本高。

串行通信
  将数据分成一位一位的形式在一条线上逐个的传送。
  优点：占用引脚少、成本低；缺点：传输速度相对较慢。





```
void UartInit(void)		//9600bps@11.0592MHz
{
	SCON = 0x50;		//8位数据,可变波特率
	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//设定定时器1为16位自动重装方式
	TL1 = 0xE0;		//设定定时初值
	TH1 = 0xFE;		//设定定时初值
	ET1 = 0;		//禁止定时器1中断，因为定时器1要作为一个波特率发生器，不断发信号给串口1.
	TR1 = 1;		//启动定时器1
}

```


